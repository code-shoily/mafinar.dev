<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on mafinar.dev</title>
    <link>/posts/</link>
    <description>Recent content in Posts on mafinar.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Mafinar K. 2021</copyright>
    <lastBuildDate>Tue, 02 Nov 2021 00:34:12 -0400</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Picking garbages in groups</title>
      <link>/posts/advent-of-code-2017-09/</link>
      <pubDate>Tue, 02 Nov 2021 00:34:12 -0400</pubDate>
      
      <guid>/posts/advent-of-code-2017-09/</guid>
      <description>In today&amp;rsquo;s post, I will describe my solution to Advent of Code year 2017, day 9&amp;rsquo;s challenge. Let&amp;rsquo;s read the challenge description before the explanation.
Part 1 Part 1 of the problem expects us to report the total number of groups, as collected from the stream of characters. The rules are simple:
 { marks the beginning of the group unless that&amp;rsquo;s found in the garbage } marks the end of the group unless that&amp;rsquo;s found in the garbage First group encounter will have the level of 1, nested groups will have their levels as their depth, as an example, the innermost group of {{{}}} will have level of 3.</description>
      <content>&lt;p&gt;In today&amp;rsquo;s post, I will describe my solution to Advent of Code year 2017, day 9&amp;rsquo;s challenge. Let&amp;rsquo;s &lt;a href=&#34;https://adventofcode.com/2017/day/9&#34;&gt;read the challenge description&lt;/a&gt; before the explanation.&lt;/p&gt;
&lt;h2 id=&#34;part-1&#34;&gt;Part 1&lt;/h2&gt;
&lt;p&gt;Part 1 of the problem expects us to report the total number of groups, as collected from the stream of characters. The rules are simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{&lt;/code&gt; marks the beginning of the group &lt;strong&gt;unless that&amp;rsquo;s found in the garbage&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;}&lt;/code&gt; marks the end of the group &lt;strong&gt;unless that&amp;rsquo;s found in the garbage&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;First group encounter will have the level of &lt;code&gt;1&lt;/code&gt;, nested groups will have their levels as their depth, as an example, the innermost group of &lt;code&gt;{{{}}}&lt;/code&gt; will have level of &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Groups are separated by commas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now that is the easy part, let&amp;rsquo;s get to the garbage.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; marks the beginning of garbage, anything after that are garbage (including &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt;), until&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is found. That marks the end of the garbage.&lt;/li&gt;
&lt;li&gt;If within the garbage, an &lt;code&gt;!&lt;/code&gt; is encountered, then the following character is discarded, whether it is another &lt;code&gt;!&lt;/code&gt; or any other delimiters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The puzzle description has great examples of what constitutes garbages and groups, and streams that would be puzzling to the eyes (such as &lt;code&gt;}&lt;/code&gt; inside garbage or &lt;code&gt;&amp;gt;&lt;/code&gt; after discards) are also there, so this problem is very test-case friendly.&lt;/p&gt;
&lt;p&gt;Our goal for this part is to add up all the group levels accummulated from the stream.&lt;/p&gt;
&lt;h3 id=&#34;the-solution&#34;&gt;The solution&lt;/h3&gt;
&lt;p&gt;This problem smelled like state machine and when dealing with F#, I could immediately picture a solution in my head. But what would aid me more is a picture of the state transitions. So I fired up a &lt;a href=&#34;https://mermaid.live/&#34;&gt;Mermaid Live&lt;/a&gt; and type in the following state transitions:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stateDiagram-v2
    [*] --&amp;gt; GroupStarted: &amp;quot;{&amp;quot; level++
    GroupStarted --&amp;gt; GroupEnded: &amp;quot;}&amp;quot; level--
    GroupStarted --&amp;gt; GarbageStarted: &amp;quot;&amp;lt;&amp;quot;
    GarbageStarted --&amp;gt; GarbageEnded: &amp;quot;&amp;gt;&amp;quot;
    GarbageEnded --&amp;gt; GroupEnded: &amp;quot;}&amp;quot;
    GarbageStarted --&amp;gt; DiscardNext: &amp;quot;!&amp;quot;
    DiscardNext --&amp;gt; GarbageStarted: Any character
    GarbageStarted --&amp;gt; GarbageStarted: Any character EXCEPT &amp;quot;&amp;gt;&amp;quot; and &amp;quot;!&amp;quot;
    GroupEnded --&amp;gt; GroupEnded: &amp;quot;,&amp;quot;
    GroupEnded --&amp;gt; GroupStarted: &amp;quot;{&amp;quot;
    GroupEnded --&amp;gt; [*]: All characters processed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the following image is produced:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/state-chart.png&#34; alt=&#34;Alt text&#34; title=&#34;State Machine&#34;&gt;&lt;/p&gt;
&lt;p&gt;We can see that, there is a &lt;code&gt;GroupMode&lt;/code&gt; and a &lt;code&gt;GarbageMode&lt;/code&gt; and the upcoming character has different effect to the overall state in different &lt;code&gt;Mode&lt;/code&gt;-s. There is also a &lt;code&gt;DiscardMode&lt;/code&gt; that discards the upcoming character, thereby affecting the closing of &lt;code&gt;GarbageMode&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;How would the F# look like?&lt;/p&gt;
&lt;p&gt;Since we are dealing with streams, we can go for a recursive function, that processes a list in &lt;code&gt;head :: rest&lt;/code&gt; pattern. And we can have a state type representing the state of the state machine. We can then have a &lt;code&gt;collection&lt;/code&gt; function that takes in a state, and then recursively calls itself, processing one character at a time - a character that resides inside the state.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s see what can we have in the state type-&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CollectionState&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;list&lt;/span&gt;
      Count&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; int
      GarbageMode&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
      DiscardMode&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
      Total&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; int &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, we have a &lt;code&gt;GarbageMode&lt;/code&gt; and a &lt;code&gt;DiscardMode&lt;/code&gt;, &lt;code&gt;Stream&lt;/code&gt; representing the characters we have left to process (and classify as a garbage or collect as a group), and &lt;code&gt;Total&lt;/code&gt; which is a sum-total of the groups collected. The &lt;code&gt;Count&lt;/code&gt; variable here adds the depth of the group.&lt;/p&gt;
&lt;p&gt;So from that definition, we have the terminating condition of the processing, when the &lt;code&gt;Stream&lt;/code&gt; is empty (aka we have processed everything). If we patternize the &lt;code&gt;Stream&lt;/code&gt; as &lt;code&gt;current :: upcoming&lt;/code&gt;, then just by giving &lt;code&gt;Stream&lt;/code&gt; the value of &lt;code&gt;upcoming&lt;/code&gt;, we are progressing through the list, churning characters. Also, we want the &lt;code&gt;Total&lt;/code&gt; to have the total number of groups.&lt;/p&gt;
&lt;p&gt;So, let&amp;rsquo;s see how a preliminary version of the function look like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; rec collect_groups &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;state&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; CollectionState&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; total
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; remaining
        Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        collect_groups
            &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                    Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remaining
                    Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1 &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, if we pass &lt;code&gt;{ Stream = input; Count = 1; GarbageMode = false; DiscardMode = false; Total = 0 }&lt;/code&gt; to it where &lt;code&gt;input&lt;/code&gt; is a string &lt;code&gt;|&amp;gt; List.ofSeq&lt;/code&gt;ified, we will, unsurprisingly, get the number of characters in that string. Because we didn&amp;rsquo;t deal with the &lt;code&gt;Mode&lt;/code&gt;-s, or character effects as portrayed in the state-chart above.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s now assume that there is just one mode - the group mode, and our input is a lot simpler one - one comprising of &lt;code&gt;{}&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; to separated them. Let&amp;rsquo;s refer back to the state chart and see what we can do -&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; rec collect_groups &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;state&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; CollectionState&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; total
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; remaining
        Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count
        Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        collect_groups
            &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                    Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remaining
                    Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1
                    Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; remaining
        Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        collect_groups
            &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                    Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remaining
                    Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1 &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; remaining &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; collect_groups &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remaining &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; failwith &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Invalid State&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This time, we compute the level and sum them up, provided we are given only &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt; amd &lt;code&gt;,&lt;/code&gt;. For example, giving &lt;code&gt;&amp;quot;{{{}},{},{},{{}}}&amp;quot; |&amp;gt; List.ofSeq&lt;/code&gt; would give us &lt;code&gt;15&lt;/code&gt;. However, the input given in the problem wouldn&amp;rsquo;t, because I intentionally made invalid state irrepresentable through that &lt;code&gt;failwith&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So when would a &lt;code&gt;&amp;lt;&lt;/code&gt; constitute the beginning of a garbage? When &lt;code&gt;GarbageMode&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;DiscardMode&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. And &lt;code&gt;&amp;gt;&lt;/code&gt; will mark the end of a garbage when &lt;code&gt;GarbageMode&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;DiscardMode&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. So, the pattern above will be updated with a &lt;code&gt;{GarbageMode = false}&lt;/code&gt; to ensure that group is formed if and only if it is not in &lt;code&gt;GarbageMode&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, if we refer to the state chart, we see that &lt;code&gt;DiscardNext&lt;/code&gt; only takes place AFTER &lt;code&gt;GarbageStarted&lt;/code&gt; happens. In other words, there is no scenario where &lt;code&gt;DiscardNext&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;GarbageMode&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, that would be impossible state, therefore, our matching should reflect that. And when in &lt;code&gt;DiscardMode&lt;/code&gt;, the flow is just &lt;code&gt;{Stream = rest}&lt;/code&gt;ed, and the &lt;code&gt;DiscardMode&lt;/code&gt; is immediately turned &lt;code&gt;off&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, if we combine the pattern above with the state chart, we can easily visualize and form the function in full -&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; rec collect_groups &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;state&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; CollectionState&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; total
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; rest
        Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count
        GarbageMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
        Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rest
                Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1
                Total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; total &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; collect_groups
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; rest
        Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count
        GarbageMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rest
                Count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1 &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; collect_groups
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; rest
        GarbageMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rest
                GarbageMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; collect_groups
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; rest
        DiscardMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rest
                DiscardMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; collect_groups
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;!&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; rest
        GarbageMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rest
                DiscardMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; collect_groups
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; rest
        GarbageMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
                Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rest
                GarbageMode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; collect_groups
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; rest &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; state &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rest &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; collect_groups
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And it worked on my machine!&lt;/p&gt;
&lt;p&gt;A few things I learned while doing this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Learned to love &lt;code&gt;{ state with ...}&lt;/code&gt; instead of forming the whole thing&lt;/li&gt;
&lt;li&gt;Made sure to not provide unnecessary patterns (i.e. &lt;code&gt;GarbageMode = true&lt;/code&gt; when that branch can never have &lt;code&gt;GarbageMode&lt;/code&gt; as true), this took a refactor and I think wasn&amp;rsquo;t totally necessary.&lt;/li&gt;
&lt;li&gt;Resisted the temptation to use tuples. Tuple could have been fine, but I preferred having the attributes in my face, instead of just a group of values.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This problem was fun to solve, and I thought I&amp;rsquo;d write about it here. Also, this had similarities with the &lt;a href=&#34;/posts/many-ways-to-reach-a-floor/&#34;&gt;first blog post I wrote in this site&lt;/a&gt; - with an added complication.&lt;/p&gt;
&lt;p&gt;Now, about Part 2 of the problem, it was very much similar to part 1 with different logic to compute the &lt;code&gt;Count&lt;/code&gt; and &lt;code&gt;Total&lt;/code&gt;. And the fact I called &lt;code&gt;Count&lt;/code&gt; &lt;code&gt;Count&lt;/code&gt; instead of the more semantically appropriate &lt;code&gt;Level&lt;/code&gt; has to do with the fact I reused this state for &lt;code&gt;Part 2&lt;/code&gt; and extracted the snippets from my original code. Both solutions can be &lt;a href=&#34;https://github.com/code-shoily/AdventOfCode/blob/master/fsharp/Y17/Year2017Day09.fs&#34;&gt;viewed from the repository&lt;/a&gt;.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Stacked Reactions</title>
      <link>/posts/stacked-reactions/</link>
      <pubDate>Mon, 02 Aug 2021 00:16:59 -0400</pubDate>
      
      <guid>/posts/stacked-reactions/</guid>
      <description>tl;dr I solved Advent of Code Year 2018, Day 5 and here is the code. When I first encountered LIFO (i.e. Stack) data structures back in my Algorithmics course, I found the implementation to be easy compared to, say linked lists, however, to identify its use in a real life problem (for instance, parenthesis matching) was something I had struggled with. I mean, I would probably be able to solve one with stitching expressions and statements together, but to immediately realize that the problem is addressable with a stack never came to me easily.</description>
      <content>&lt;h5 id=&#34;tldr-i-solved-advent-of-code-year-2018adventofcodecom2018day5-day-5-and-here-is-the-codegithubcomcode-shoilyadventofcodeblobmasterfsharpy18year2018day05fs&#34;&gt;tl;dr I solved &lt;a href=&#34;//adventofcode.com/2018/day/5&#34;&gt;Advent of Code Year 2018&lt;/a&gt;, Day 5 and &lt;a href=&#34;//github.com/code-shoily/AdventOfCode/blob/master/fsharp/Y18/Year2018Day05.fs&#34;&gt;here is the code&lt;/a&gt;.&lt;/h5&gt;
&lt;p&gt;When I first encountered LIFO (i.e. Stack) data structures back in my Algorithmics course, I found the implementation to be easy compared to, say linked lists, however, to identify its use in a real life problem (for instance, parenthesis matching) was something I had struggled with. I mean, I would probably be able to solve one with stitching expressions and statements together, but to immediately realize that the problem is addressable with a stack never came to me easily. I eventually overcame that (Or so I think), and today&amp;rsquo;s post, and the advent of code puzzle involved, involves a LIFO.&lt;/p&gt;
&lt;p&gt;So what does the &lt;a href=&#34;//adventofcode.com/2018/day/5&#34;&gt;description&lt;/a&gt; say? To summarize, any &lt;code&gt;&amp;lt;lower-case&amp;gt;&amp;lt;upper-case&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;upper-case&amp;gt;&amp;lt;lower-case&amp;gt;&lt;/code&gt; sequence of the same letter needs to evaporate in a sequence of letters (unit type, they say), and you keep collapsing such pairs until there remains no other pairs that satisfy the logic. That&amp;rsquo;s when you output the length of a non-reducible sequence of units.&lt;/p&gt;
&lt;p&gt;To give an example (I copied the example from the site as-is):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dabAcCaCBAcCcaDA  The first &#39;cC&#39; is removed.
dabAaCBAcCcaDA    This creates &#39;Aa&#39;, which is removed.
dabCBAcCcaDA      Either &#39;cC&#39; or &#39;Cc&#39; are removed (the result is the same).
dabCBAcaDA        No further actions can be taken.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The result of the above sequence would be the length of the non-reducible sequence &lt;code&gt;dabCBAcaDA&lt;/code&gt;, or &lt;code&gt;10&lt;/code&gt;. Now they slapped me with a &lt;code&gt;50_000&lt;/code&gt; character sequence that is to follow this process.&lt;/p&gt;
&lt;p&gt;When writing programs in F# (and I only had 17 days of it), I found that treating input as a sequence, and pouring that sequence through a series of transformations helps me produce tolerable looking code. And to assume that everything already happened and exists (as oppose to my function making them happen) helps me further.&lt;/p&gt;
&lt;p&gt;For instance, let&amp;rsquo;s see how I would see the sequence of &lt;code&gt;units&lt;/code&gt; as mentioned here transform to get my non-reducible output:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;daBbAcCd                                                                    The input.
&#39;d&#39; &#39;a&#39; &#39;B&#39; &#39;b&#39; &#39;A&#39; &#39;c&#39; &#39;C&#39; &#39;d&#39;                                             As Character Stream
(&#39;d&#39; &#39;a&#39;) (&#39;a&#39; &#39;B&#39;) (&#39;B&#39; &#39;b&#39;) (&#39;b&#39; &#39;A&#39;) (&#39;A&#39; &#39;c&#39;) (&#39;c&#39; &#39;C&#39;) (&#39;C&#39; &#39;d&#39;)       In two-s
(&#39;d&#39; &#39;a&#39;) (&#39;a&#39; _) (_ &#39;A&#39;) (&#39;A&#39; _) (_ &#39;d&#39;)                                   Get rid of (a, b) where (lower a) = (lower b)
&#39;d&#39; &#39;a&#39; &#39;A&#39; &#39;d&#39;                                                             Stringify them
(&#39;d&#39; &#39;a&#39;) (&#39;a&#39; &#39;A&#39;) (&#39;A&#39; &#39;d&#39;)                                               In two-s (Again)
(&#39;d&#39; _) (_ &#39;d&#39;)                                                             Get rid of (a, b) where (lower a) = (lower b)  
&#39;d&#39; &#39;d&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This series transformations works, in paper and pencil, and given &lt;code&gt;Seq.windowed&lt;/code&gt; exists and there is nothing one can&amp;rsquo;t do with &lt;code&gt;Seq.fold&lt;/code&gt;, I am fairly certain that I could whip up a nice little F# code out of it. Possible? Yes. Succint? Maybe. Elegant? I am not quite sure.&lt;/p&gt;
&lt;p&gt;So, I gave myself fifteen more minutes to think a bit more on this. I used the term &amp;ldquo;pour&amp;rdquo; earlier, so what if I pour in the &lt;code&gt;unit type&lt;/code&gt;-s, hold what I just poured and match it with the next drop? Let&amp;rsquo;s sketch it again:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;daBbAcCd                            The input.
&#39;d&#39; &#39;a&#39; &#39;B&#39; &#39;b&#39; &#39;A&#39; &#39;c&#39; &#39;C&#39; &#39;d&#39;     As Character Stream
&#39;d&#39; | &#39;a&#39; &#39;B&#39; &#39;b&#39; &#39;A&#39; &#39;c&#39; &#39;C&#39; &#39;d&#39;   Partition after head, &#39;d&#39; | &#39;a&#39;, move right.
&#39;d&#39; &#39;a&#39; | &#39;B&#39; &#39;b&#39; &#39;A&#39; &#39;c&#39; &#39;C&#39; &#39;d&#39;   &#39;a&#39; | &#39;B&#39;, move right
&#39;d&#39; &#39;a&#39; &#39;B&#39; | &#39;b&#39; &#39;A&#39; &#39;c&#39; &#39;C&#39; &#39;d&#39;   &#39;B&#39; | &#39;b&#39;, delete both sides of partition, stay
&#39;d&#39; &#39;a&#39; | &#39;A&#39; &#39;c&#39; &#39;C&#39; &#39;d&#39;           &#39;a&#39; | &#39;A&#39;, delete both sides of partition, stay
&#39;d&#39; | &#39;c&#39; &#39;C&#39; &#39;d&#39;                   &#39;d&#39; | &#39;C&#39;, move right
&#39;d&#39; &#39;c&#39; | &#39;C&#39; &#39;d&#39;                   &#39;c&#39; | &#39;C&#39;, delete both sides of partition, stay
&#39;d&#39; | &#39;d&#39;                           &#39;d&#39; | &#39;d&#39;, move right
&#39;d&#39; &#39;d&#39; |                           DONE
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now this makes some sense, I can focus on line 1, and trace down to line 10 in one breath, without ever backtracking my thoughts. I will now implement this in code.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look into what are on the left and right sides of the &lt;code&gt;|&lt;/code&gt;. If I take the left-most character from the right partition of the sequence, and compare it with the right most character of the left partition, and use a comparison function to decide whether it will &lt;code&gt;append&lt;/code&gt; to the left partition, or self destruct and take that right-most part with it, then at any given point of time, tight left partition (from &lt;code&gt;|&lt;/code&gt;) will always contain the non-reducible units, while the right partition will contain the yet to be reacted ones. Now all I need to do is, progress the &lt;code&gt;|&lt;/code&gt; forward!&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s rephrase, at any given snapshot of &lt;code&gt;0 1 2 3 4 | 5 6 7&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt; will be compared with &lt;code&gt;5&lt;/code&gt; and if they are to react, the data structure will look like &lt;code&gt;0 1 2 3 | 6 7&lt;/code&gt; and if they are to not react, then it would look like &lt;code&gt;0 1 2 3 4 5 | 6 7&lt;/code&gt;. So, the left data structure needs only to append or remove efficiently to the right most element (aka the last inserted item). So before I (finally), get into the code, I&amp;rsquo;d need the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A mechanism to read one element of a sequence&lt;/li&gt;
&lt;li&gt;A function that lets me compare two characters and decide whether they react or not, and&lt;/li&gt;
&lt;li&gt;A stack, that will maintain the &lt;code&gt;visited&lt;/code&gt; values and with the exception of the top-most (right-most) character, it is guaranteed that no reaction can be possible.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&amp;rsquo;s how my &lt;code&gt;react&lt;/code&gt; function looks like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; react sequence &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    sequence
    &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.fold
        &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; visited unitType &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; visited &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; nonReactive &lt;span style=&#34;color:#66d9ef&#34;&gt;when&lt;/span&gt; abs &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;unitType &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; right&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 32 &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; nonReactive
            &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; unitType &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; visited&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
        List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;.&lt;/span&gt;Empty
    &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.length
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This worked, and gave me a sweet &lt;code&gt;* (gold star)&lt;/code&gt;. Oh, I decided to &lt;code&gt;int&lt;/code&gt; my character stream as the pre-processing ritual, though I realized I could just as well have kept it as a string sequence and compared with converting both to either lower or upper case.&lt;/p&gt;
&lt;p&gt;Also, since I am using &lt;code&gt;fold&lt;/code&gt; anyway, why not compute the &lt;code&gt;length&lt;/code&gt; on the fly and keep it as a &lt;code&gt;state&lt;/code&gt;? And get some point-freedom while at it? And let&amp;rsquo;s just use some Stack terminologies.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; react &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    Seq.fold
        &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;length&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; unitType &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; stack &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; top &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; bottom &lt;span style=&#34;color:#66d9ef&#34;&gt;when&lt;/span&gt; abs &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;unitType &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; top&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 32 &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; bottom&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;length &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; unitType &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;.&lt;/span&gt;Empty&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; fst
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I am happy with this code. And that concludes part 1.&lt;/p&gt;
&lt;p&gt;About part 2, well, it&amp;rsquo;s just part 1 with some pseudo-brute-forcing. What if we removed all &lt;code&gt;a|A&lt;/code&gt;-s from the sequence and ran the reaction? What if we removed &lt;code&gt;b|B&lt;/code&gt;s? &lt;code&gt;c|C&lt;/code&gt;-s? So you can see, we just need to call &lt;code&gt;react&lt;/code&gt; function on 26 different inputs, and find the shortest non-reducable sequence. And this code looked like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; solvePart2 input &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    seq &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 65 &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt; 90 &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.map
        &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; currentUnit &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
            input
            &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; parse
            &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.filter
                &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; unitType &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
                    unitType &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; currentUnit
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; unitType &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;currentUnit &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 32&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; react&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.min
    &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So that concludes my day 17. I know my last blog post was labelled &lt;code&gt;Day 1&lt;/code&gt; and this one &lt;code&gt;Day 17&lt;/code&gt; (Or is it 16?), I solved 15 other problems in between while focusing on learning the language and didn&amp;rsquo;t quite get the time to write about it. This one however, I wrote as I solved the problem and that was fun. Maybe I will do it more often.&lt;/p&gt;
&lt;p&gt;Until I solve another problem, or pick up one of the solve problems to discuss here, have a great evening!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Many Ways to Reach a Floor</title>
      <link>/posts/many-ways-to-reach-a-floor/</link>
      <pubDate>Wed, 14 Jul 2021 09:09:23 -0400</pubDate>
      
      <guid>/posts/many-ways-to-reach-a-floor/</guid>
      <description>This is day 1 of my #100DaysOfFSharp and in this post I will talk about what I learned today. I tried solving Advent of Code 2015&amp;rsquo;s Day 1 - an easy problem that packed a lot of F# education for me.
The problem is stated in the link but the tl;dr of it is climbing up and down based on a specific instruction - ( means going up while ) means down.</description>
      <content>&lt;p&gt;This is day 1 of my #100DaysOfFSharp and in this post I will talk about what I learned today. I tried solving &lt;a href=&#34;https://adventofcode.com/2015/day/1&#34;&gt;Advent of Code 2015&amp;rsquo;s Day 1&lt;/a&gt; - an easy problem that packed a lot of F# education for me.&lt;/p&gt;
&lt;p&gt;The problem is stated in the link but the &lt;code&gt;tl;dr&lt;/code&gt; of it is climbing up and down based on a specific instruction - &lt;code&gt;(&lt;/code&gt; means going up while &lt;code&gt;)&lt;/code&gt; means down. And the input is a lot parenthesis- reminiscent of Lisp jokes. The title of the problem: &lt;code&gt;Not Quite Lisp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We have two parts of the puzzle here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If one starts from ground floor and follows the given instruction set, the program should figure out what floor will be reached after all up/down instructions are followed.&lt;/li&gt;
&lt;li&gt;If one starts from ground floor and scans the given instruction set, the program should figure out how many steps will be required to reach the basement.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0 = Ground Floor. -1 = Basement.&lt;/p&gt;
&lt;h2 id=&#34;part-1&#34;&gt;Part 1&lt;/h2&gt;
&lt;p&gt;F# is a &amp;ldquo;functional first&amp;rdquo; language, which means I should be able to do things without thinking too functionally. This should also be an opportunity for me to see how to deal with mutations here, as it is more than likely that I might not be doing too many mutables in future. So let&amp;rsquo;s think this problem through the procedural lens. I read up on &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/&#34;&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/loops-for-in-expression&#34;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; in F# and came up with the following snippet. Loved that &lt;code&gt;&amp;lt;-&lt;/code&gt; for mutation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; toFloorIter instructions &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mutable destinationFloor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; instructions &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
            destinationFloor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; destinationFloor &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            destinationFloor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; destinationFloor &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1

    destinationFloor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That worked well! now let&amp;rsquo;s get to the &amp;ldquo;Functional&amp;rdquo; bit. Why not replace all the &lt;code&gt;(&lt;/code&gt;s with &lt;code&gt;1&lt;/code&gt;s and &lt;code&gt;)&lt;/code&gt;s with &lt;code&gt;-1&lt;/code&gt;s and sum it up? That looks like a thing that is simple and should work? Let&#39; grab a module that gives me maps, reduces, filter etc and do it!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; toFloorWithMap &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;instructions&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    instructions
    &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.map&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; instruction &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; instruction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt; 1 &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.sum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Pipes are awesome.&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s try reduction! I mean, I could (and did) totally reinvent the wheel and replace &lt;code&gt;Seq.sum&lt;/code&gt; with &lt;code&gt;Seq.reduce (+)&lt;/code&gt; but reducing flow could potentially save me a step in the pipeline. In other words, I can start with 0, and a reducer function that takes it, and an char from the instruction and either increments or decrements it, then by the time I am done scanning the list, I should be reaching the desired floor. In the process, I can extract the &lt;code&gt;if ... then&lt;/code&gt; logic into its own function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; followInstruction current instruction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; instruction &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
        current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
        current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1 

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; toFloorWithFold &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;instructions&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    Seq.fold followInstruction 0 instructions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I said reduce but used fold, that is because I needed an initial state and the result type is not type the sequence is of. I would thank IDE and strong typing for teaching me this without having to StackOverflow (I use Jetbrains Rider). I &lt;strong&gt;did&lt;/strong&gt; try &lt;code&gt;reduce&lt;/code&gt;. The typespec is so beautifully legible:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;List.fold &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;State &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;T &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;State&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;State &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;T &lt;span style=&#34;color:#66d9ef&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;State
List.reduce &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;T &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;T &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;T &lt;span style=&#34;color:#66d9ef&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;#39;&lt;/span&gt;T
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before going point-free there was one thing I wished to check for- I used &lt;code&gt;if then else&lt;/code&gt; without checking for &lt;code&gt;(&lt;/code&gt;, assuming the input is comprised solely of &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; (it actually is), however, while depending on how I pull the inputs, there could be an &lt;code&gt;&amp;quot;\n&amp;quot;&lt;/code&gt; or an unwanted &lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt; lying around. Also, this is an opportunity to use the match operator! So if I had to refactor &lt;code&gt;followInstruction&lt;/code&gt; to use pattern matching:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; followInstructions current instruction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; instruction &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&amp;hellip;or I could &lt;code&gt;failwith&lt;/code&gt; a message, but let&amp;rsquo;s assume anything other than &lt;code&gt;(|)&lt;/code&gt; is inconsequential.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s see if we can go point free. &lt;code&gt;toFloorWithFold&lt;/code&gt; can be &lt;code&gt;fun instruction -&amp;gt; ...&lt;/code&gt; and since &lt;code&gt;f(x, y)&lt;/code&gt; is &lt;code&gt;f(x)(y)&lt;/code&gt;, by leaving out &lt;code&gt;instructions&lt;/code&gt; parameter, I can have this return a function that takes that missing &lt;code&gt;instructions&lt;/code&gt; as parameter. Which leads me to:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; toFloorWithFoldPointFree &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; seq&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 
    Seq.fold followInstructions 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And F# forced me to add typed in this version! Which led me to &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/automatic-generalization&#34;&gt;this nice article&lt;/a&gt;. Let&amp;rsquo;s liberate the mapped version from shackles of a point:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let toFloorWithMapPointFree : seq&amp;lt;char&amp;gt; -&amp;gt; int =
    Seq.map (followInstructions 0) &amp;gt;&amp;gt; Seq.sum
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; composes two functions, kindof like a curried &lt;code&gt;|&amp;gt;&lt;/code&gt;. There&amp;rsquo;s also a &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. I have never use such a construct before though I see myself using it a lot. That one-liner read as &amp;ldquo;Create a function that maps each element of the &amp;ldquo;seqable&amp;rdquo; it receives to &lt;code&gt;followInstruction&lt;/code&gt; function, giving it &lt;code&gt;0&lt;/code&gt;; then it just sums it&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Wow, quite a few ways to reach a floor! Now let&amp;rsquo;s see how many steps we&amp;rsquo;d need to get to the basement!&lt;/p&gt;
&lt;h2 id=&#34;part-2&#34;&gt;Part 2&lt;/h2&gt;
&lt;p&gt;This too is an easy problem to solve. Instead of looping over the instructions and updating the &lt;code&gt;currentFloor&lt;/code&gt; TILL THE END, we stop iterating when the &lt;code&gt;currentFloor&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; and the &lt;code&gt;counter&lt;/code&gt; at that time is our answer. So a C style &lt;code&gt;for loop&lt;/code&gt; with a &lt;code&gt;break&lt;/code&gt; would be perfect for it. Or &lt;code&gt;while&lt;/code&gt;, like below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; toBasementWhile &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;instructions&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mutable steps &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mutable current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; instructionArray &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; instructions&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ToCharArray()
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1 &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; instructionArray&lt;span style=&#34;color:#f92672&#34;&gt;.[&lt;/span&gt;steps&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
            current &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            current &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1
        steps &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; steps &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1
    steps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I could not find a sane looking &lt;code&gt;break&lt;/code&gt; policy for a loop in F#, and &lt;code&gt;ToCharArray&lt;/code&gt; is a method my recent encounters with C# familiarized me with, so grabbed it. And again, it worked!&lt;/p&gt;
&lt;p&gt;Enough with the iterative approach, let&amp;rsquo;s try some good old fashioned recursion.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; rec doStepsToBasement &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;step&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; step
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;step&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; instructions&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; doStepsToBasement &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;step &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; instructions&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;step&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; instructions&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; doStepsToBasement &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;step &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; instructions&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; failwith &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Invalid input&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; stepsToBasementRecur &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;instructions&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    doStepsToBasement &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; instructions &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.map &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; l&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&amp;gt;&lt;/span&gt; Seq.toList&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Rest style pattern matching is one of my favorite super powers. I could just visualize an instruction as a dispenser, dispensing one instruction at a time, until it&amp;rsquo;s empty, and everytime the spitted out parenthesis, the &lt;code&gt;-1&lt;/code&gt;ed instruction list and all computed states are pushed back into the same function! Pretty. (That made absolutely no sense now did it?)&lt;/p&gt;
&lt;p&gt;I searched for a &lt;code&gt;reduce_while&lt;/code&gt; in &lt;code&gt;Seq&lt;/code&gt; but could not find any, but there is a &lt;code&gt;scan&lt;/code&gt;, which is like a dispenser of reduced items on the fly, so, why not do something like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; stepsToBasement &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; seq&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
    Seq.map &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;followInstructions 0&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; Seq.scan &lt;span style=&#34;color:#f92672&#34;&gt;(+)&lt;/span&gt; 0
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; Seq.findIndex &lt;span style=&#34;color:#f92672&#34;&gt;((=)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And this time point-freedom came naturally to me! Didn&amp;rsquo;t miss &lt;code&gt;reduce-while&lt;/code&gt; much. And also, I did think about &lt;code&gt;Seq.indexed&lt;/code&gt; and then scanning but luckily I found out about &lt;code&gt;findIndex&lt;/code&gt; early on.&lt;/p&gt;
&lt;p&gt;And that ends my day 1 of the 100 days of F#.&lt;/p&gt;
&lt;h2 id=&#34;my-approach-at-learning-things-today&#34;&gt;My approach at learning things today&lt;/h2&gt;
&lt;p&gt;So this was a really interesting experience for me. Usually I learn languages (ones I learn for fun) from books- I buy a book and work through the examples, the most recent one being &amp;ldquo;C# 9.0 Pocket Reference&amp;rdquo;. However in this case, I just went head-on with problem solving armed only with common-sense. I picked a problem, thought of ways to solve it, and googled generic applicable terms to come up with F# artifacts to help me construct outcomes. This took longer time and slower (initial) progress but it did give me that feeling of &amp;ldquo;struggle&amp;rdquo; and &amp;ldquo;resistance&amp;rdquo; which leads to true appreciation of the programming language. I had no idea what an F# &lt;code&gt;Seq&lt;/code&gt; meant, what separated &lt;code&gt;reduce&lt;/code&gt; from &lt;code&gt;fold&lt;/code&gt;, or how I would mutate the mutable. Those would probably not be colocated in one chapter of (m)any books, but I dug scattered information from the web and stayed in REPL until everything made sense. And that was a fun, fulfilling learning experience, more of which I look forward too.&lt;/p&gt;
&lt;h2 id=&#34;any-final-words&#34;&gt;Any final words?&lt;/h2&gt;
&lt;p&gt;The official F# documentation is beyond awesome. The article on Automatic Generalization had little to do with my work today but I stumbled upon it any way, and got pretty well enlightened. Almost every article I read from the docuemtation site has been enjoyable and to the point. For example, &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fsharp-collection-types&#34;&gt;this page&lt;/a&gt; is something every language should cover! As for the day 1 in general, this has been a much entertaining day for me. I can safely say that I am looking forward to the 99 other days and beyond! My gratitude to everyone involved in creating and nurturing this amazing language!&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
